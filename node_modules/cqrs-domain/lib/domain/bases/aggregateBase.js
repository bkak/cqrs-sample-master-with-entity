var utils = require('../../utils')
  , async = require('async')
  , _ = require('lodash');

var Aggregate = function(id) {
    this.id = id;
    this.events = [];
    this.attributes = { id: id, revision: 0, destroyed: false };
};

Aggregate.prototype = {
    setRecursive : function(dest, array, arrname){
        var self = this;
        if(dest[arrname] === undefined)
            dest[arrname] = [];
        _.each(array[arrname], function(source){
            var obj = self.classtypes[arrname];
            var obj1 = new self[obj]();
            for(var m in source) {
                if(source[m] &&  source[m].constructor.name === "Array")
                {
                    self.setRecursive(dest, source, m);
                }
                else
                {
                    obj1[m] = source[m];
                }
            }
            dest[arrname].push(obj1);
        });
    },
    set: function(data) {
        var self = this;
        this.attributes = _.extend(this.attributes, this.customattributes);
        //Here is the problem.
        //The array count should reset. It remains the same when another instance of same AR is loaded
        console.log("Unit count before loading AR " + this.attributes.units.length);

        if (arguments.length === 2) {
            this.attributes[arguments[0]] = arguments[1];
        } else {
            for(var m in data) {

                if(data[m] && data[m].constructor.name === "Array")
                {
                    self.setRecursive(self.attributes, data, m);
                }
                else
                {
                    self.attributes[m] = data[m];
                }
            }
        }
    },

    get: function(attr) {
        return this.attributes[attr];
    },

    toJSON: function() {
        // var parse = JSON.deserialize || JSON.parse;
        // var json = parse(JSON.stringify(this.attributes));
        // return json;
        return _.clone(this.attributes);
    },

    toEvent: function(name, data) {
        var event = { 
            event: name, 
            payload: data || {}
        };

        if (!event.payload.id) event.payload.id = this.id;

        return event;
    },

    load: function(data) {
        if (data) {
            this.set(data);
        }
    },

    apply: function(events, callback) {
        var self = this;

        if (!_.isArray(events)) {
            events = [events];
        }

        var historyEvents = [];
        var newEvents = [];
        _.each(events, function(evt) {
            if (evt.fromHistory) {
                historyEvents.push(evt);
            } else {
                newEvents.push(evt);
            }
        });

        _.each(historyEvents, function(evt) {
            self[evt.event](evt.payload);
        });

        this.previousAttributes = this.toJSON();

        _.each(newEvents, function(evt) {
            self[evt.event](evt.payload);
            evt.head = { revision: ++self.attributes.revision };
            self.events.push(evt);
        });

        if (callback) callback(null);

        return;
    },

    checkBusinessRules: function(callback) {
        var self = this;
        var changedAttributes = this.toJSON();
        var keys = [];

        if(!this.businessRules) return callback(null);

        async.each(this.businessRules, function(rule, callback) {
            rule.call(self, changedAttributes, self.previousAttributes, self.uncommittedEvents, function(ruleId, message) {
                if (ruleId) {
                    if (!message) {
                        message = ruleId;
                        ruleId = arguments.callee.caller.name;
                    }
                    keys.push({ type: 'businessRule', ruleId: ruleId, message: message });
                }
                callback(null);
            });
        }, function() {
            if (keys.length > 0) {
                self.attributes = self.previousAttributes;
                callback(keys);
            } else {
                callback(null);
            }
        });
    }

};

Aggregate.extend = utils.extend;

module.exports = Aggregate;